---
title: "数据结构之前言"
date: 2016-05-10 23:01:37 +0800
category: C
excerpt: 在开始数据结构之前，先来看看一些小的知识预热一下。主要是计算机内存的分配，指针的风险，以及数组的存储分配。
tags:
- 数据结构
- C语言
---

## 计算机内存分配

首先要清楚的是，在计算机中，并不存在内容的删除，只有内容的覆盖，这也是为什么会有数据恢复这种技术了！

![空闲区与占用区](https://www.z4a.net/images/2017/08/31/data.png)

比如说你在 Word 里编辑你的文件，假如你输入了三个字符，你删除之后，你认为就安全了吗？别人不可能恢复了吗？这样做还是不能销毁你的记录，只有通过更大的内容去覆盖你之前的内容，这样，之前的内容才会被『销毁』。尼玛，真有趣！

值得注意的是，在空闲区也是可能有原始数据的。

在 C 里 , & 表示取地址 , \* 表示取内容

``` c
int x;
int *p; // 这里的 * 与取内容区分一下，这里是申明 p 为地址变量，用来存放地址
int **q; // 那么这里的 q 就是存放地址变量的地址
x = 2;
p = &x; // 这里将 x 的地址传给了 p 这个地址变量，如果此时输出 p，将是一个 x 的地址
q = &p; // 这里将 p 这个地址变量的地址传给了 q 这个地址变量，如果此时输出q，将是一个 p 的地址
```

那么 `*p = x`，`*q = p` ，`*(*q) = x = 2` 。

## 指针的风险 —— 悬挂式指针

为什么说使用指针是要谨慎，因为一不小心就可能造成系统的崩溃，让我们来看看是怎么回事。

``` c
int *x, *y, a=1, b=2;
int *t;
x = &a;
y = &b;
*t = *x;
*x = *y;
*y = *t;
```

上面这个程序，利用了一个中间变量实现了 a，b 的数据交换，看似是没有问题的，好像我也是经常这样干!但是，在内存的分配里我们讲到了空闲区也有可能是有它原本的数据存在的。这里我们假设一下，如果申请的 `指针变量 t` 原本就是有数据假设为 1000，那么我们将 `a = 1` 暂存到 `t 指针` 所指向的地址空间，即地址为 1000 的这个空间，如果说恰好地址为 1000 的空间又是**存放系统文件**的，那么不可避免的造成 bug、死机甚至是系统的崩溃。

## 数组存取

``` c
int a[9];
```
一个整型占两个字节，这里系统会为这个数组申请 18 个字节的空间：

![数组存储](https://www.z4a.net/images/2017/08/31/array_storage.png)

而 a 就是首地址，即：

``` c
*a = a[0]
*(a+2) = a[2] // 这里隐含的地址 +4
```

而：

``` c
int b[5][5];
```

![二维数组存储](https://www.z4a.net/images/2017/08/31/two_dimensional_array_storage.png)

除 `b[?][?]` 表示是具体的数值外，其它表示全为地址

eg：`b+1` 为 `b[1]` 的地址 —— 行地址，`b[0]+1` 为 `b[0][1]` 的地址 —— 列地址。

``` c
int *p; // 列地址
int (*q)[5]; // 行地址，这里 q+1 将会跳 5 个数据，q 相当于 b
int *t[5]; // 数组指针
```
